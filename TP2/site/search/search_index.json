{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TP2 - Graphs This TP contains basic data structures like lists and stacks that are ultimately used to implement graph algorithms.","title":"TP2 - Graphs"},{"location":"#tp2-graphs","text":"This TP contains basic data structures like lists and stacks that are ultimately used to implement graph algorithms.","title":"TP2 - Graphs"},{"location":"example/","text":"Hello world alsdljf","title":"Hello world"},{"location":"example/#hello-world","text":"alsdljf","title":"Hello world"},{"location":"graph/","text":"Here are some nifty graphs my dude","title":"Graph"},{"location":"list/","text":"Node / Vertex A Node is the implementation of a Linked List data structure whose data types are integers. That is, every Node has a (possibly null) pointer pointing to the next Node and also a data field of type integer. typedef struct node_t { int data; struct node_t *next; } Node typedef (Node *) Vertex; Used throughout this project is the typedef Vertex -> Node * so that I can more easily reason about the algorithms used to traverse graphs. Thus, in the example codes we will see a lot of Vertex s rather than Node * . Instantiation To create a new linked list, simply use the function newNode constructor Vertex v1 = newNode(1); Vertex v2 = newNode(2); Vertex v3 = newNode(3); Vertex v4 = newNode(4); v3->next = v2; v2->next = v4; v4->next = v1; This example creates a list whose nodes data is connected as: 3 -> 2 -> 4 -> 1 We can duplicate the contents of a list with duplicateList , which returns a list whose nodes have been newly allocated. Vertex list2 = duplicateList(v3); Memory The individual vertices that reside in a linked list can be cleared with the function freeList . Individual nodes can be freed with freeNode . It turns out that there are actually no functions to add another Node to an existing linked list as all that higher-level behavior is incorporated in the Graph algorithms like addEdge . The main functionality described by list.h (which declares the Node and Vertex types) are utility functions that are directly called by other examples. For the routine writeVertex is used when writing a Graph as a dot file. countUnvisitedVertex is a special function that takes a list of vertices in as an argument along with a boolean array of previously visited vertices to determine the number of unvisited vertices residing in the list.","title":"Node / Vertex"},{"location":"list/#node-vertex","text":"A Node is the implementation of a Linked List data structure whose data types are integers. That is, every Node has a (possibly null) pointer pointing to the next Node and also a data field of type integer. typedef struct node_t { int data; struct node_t *next; } Node typedef (Node *) Vertex; Used throughout this project is the typedef Vertex -> Node * so that I can more easily reason about the algorithms used to traverse graphs. Thus, in the example codes we will see a lot of Vertex s rather than Node * .","title":"Node / Vertex"},{"location":"list/#instantiation","text":"To create a new linked list, simply use the function newNode constructor Vertex v1 = newNode(1); Vertex v2 = newNode(2); Vertex v3 = newNode(3); Vertex v4 = newNode(4); v3->next = v2; v2->next = v4; v4->next = v1; This example creates a list whose nodes data is connected as: 3 -> 2 -> 4 -> 1 We can duplicate the contents of a list with duplicateList , which returns a list whose nodes have been newly allocated. Vertex list2 = duplicateList(v3);","title":"Instantiation"},{"location":"list/#memory","text":"The individual vertices that reside in a linked list can be cleared with the function freeList . Individual nodes can be freed with freeNode . It turns out that there are actually no functions to add another Node to an existing linked list as all that higher-level behavior is incorporated in the Graph algorithms like addEdge . The main functionality described by list.h (which declares the Node and Vertex types) are utility functions that are directly called by other examples. For the routine writeVertex is used when writing a Graph as a dot file. countUnvisitedVertex is a special function that takes a list of vertices in as an argument along with a boolean array of previously visited vertices to determine the number of unvisited vertices residing in the list.","title":"Memory"},{"location":"overview/","text":"SUP YALL!!! This is a basic overview","title":"Overview"},{"location":"overview/#sup-yall","text":"This is a basic overview","title":"SUP YALL!!!"},{"location":"stack/","text":"Stack We can use the Stack structure as a LIFO container that is used to implement BFS and routines to determine strongly connected components. To instantiate a Stack , we use the function newStack to return a pointer to newly allocated Stack that currently holds no Vertex Construction Stack *s = newStack(); Push/Pop To Add vertices to the stack, we simple call the companion functions pushStack / popStack . Following conventions, pushing to the stack will add a new element on top whereas popping the stack will remove the top element from the stack and then return that element. pushStack(s, 10); pushStack(s, 40); pushStack(s, 13); Vertex v0 = popStack(s); Vertex v1 = popStack(s); Vertex v2 = popStack(s); Freeing Memory When it comes to freeing the memory that has been allocated on subsequent calls to pushStack , we can use handy utility function freeStack . This routine will remove all of the Vertex objects that currently exist in the stack, freeing them as they are released. pushStack(s, 1); pushStack(s, 2); pushStack(s, 3); printf(\"Size of stack %d\\n\", stackSize(s)); // 3 freeStack(s); printf(\"Size of stack %d\\n\", stackSize(s)); // 0 pushStack(s, 10); This routine is useful when we want a fresh start with the stack and we don't want any memory leaks in our program. If you no longer wish to use the Stack *s , consider calling the releaseStack function to also clean up the space allocated by newStack and to nullify the pointer s. releaseStack(&s) // s freed and set to NULL here releaseStack will free all of the nodes populating the stack and also release the memory pointed to by s . This shall be called when your program no longer needs to use the Stack . Inquiry We can inspect the state of our Stack using the utility functions stackSize and printStack .","title":"Stack"},{"location":"stack/#stack","text":"We can use the Stack structure as a LIFO container that is used to implement BFS and routines to determine strongly connected components. To instantiate a Stack , we use the function newStack to return a pointer to newly allocated Stack that currently holds no Vertex","title":"Stack"},{"location":"stack/#construction","text":"Stack *s = newStack();","title":"Construction"},{"location":"stack/#pushpop","text":"To Add vertices to the stack, we simple call the companion functions pushStack / popStack . Following conventions, pushing to the stack will add a new element on top whereas popping the stack will remove the top element from the stack and then return that element. pushStack(s, 10); pushStack(s, 40); pushStack(s, 13); Vertex v0 = popStack(s); Vertex v1 = popStack(s); Vertex v2 = popStack(s);","title":"Push/Pop"},{"location":"stack/#freeing-memory","text":"When it comes to freeing the memory that has been allocated on subsequent calls to pushStack , we can use handy utility function freeStack . This routine will remove all of the Vertex objects that currently exist in the stack, freeing them as they are released. pushStack(s, 1); pushStack(s, 2); pushStack(s, 3); printf(\"Size of stack %d\\n\", stackSize(s)); // 3 freeStack(s); printf(\"Size of stack %d\\n\", stackSize(s)); // 0 pushStack(s, 10); This routine is useful when we want a fresh start with the stack and we don't want any memory leaks in our program. If you no longer wish to use the Stack *s , consider calling the releaseStack function to also clean up the space allocated by newStack and to nullify the pointer s. releaseStack(&s) // s freed and set to NULL here releaseStack will free all of the nodes populating the stack and also release the memory pointed to by s . This shall be called when your program no longer needs to use the Stack .","title":"Freeing Memory"},{"location":"stack/#inquiry","text":"We can inspect the state of our Stack using the utility functions stackSize and printStack .","title":"Inquiry"}]}